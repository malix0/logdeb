package logdeb

import (
	"bytes"
	"fmt"
	"sync"
)

const cPckName = "logdeb"

// Log severity
const (
	SevDeb  = iota + 1 // debug
	SevInfo            // information
	SevWarn            // warning
	SevErr             // error
	SevFat             // fatal
)

// Debug level
const (
	DLZ   = iota // zero, no debug
	DLB          // base
	DLE          // extended
	DLV          // verbose
	DLVV         // very verbose
	DLVVV        // even more verbose
)

type SLogger struct {
	lock     sync.Mutex            // ensures atomic writes; protects the following fields
	funcName string                // prefix to write at beginning of each line
	severity tSeverity             // Log severity
	msgChan  chan *TLogMsg         // Channels that will dispatch the log messages
	writers  map[string]ILogWriter // Log writers
	buf      bytes.Buffer          // for accumulating text to write
}

type tSeverity int8

type TLogMsg struct {
	fnc string
	msg string
	sev tSeverity
}

type ILogWriter interface {
	Init(params ...interface{}) error
	Write(msg TLogMsg) error
	Destroy()
	Flush()
}

type tLogWriter func() ILogWriter

var logWriters = make(map[string]tLogWriter)

func NewLogDeb(bufferSize int64) *SLogger {
	l := new(SLogger)
	l.msgChan = make(chan *TLogMsg, bufferSize)
	l.writers = make(map[string]ILogWriter)
	go l.StartWriter()

	// Read writers and their configuration from jsonconfig

	// TODO : Aggiungere in input la configurazione json
	l.lock.Lock()
	defer l.lock.Unlock()
	//if log, ok := adapters[adaptername]; ok {
	if logWriter, ok := writer; ok {
		lw := logWriter()
		lw.Init(config)
		l.writers[name] = lw
		return nil
	} else {
		return fmt.Errorf("logs: unknown adaptername %q (forgotten Register?)", adaptername)
	}

	return l
}

func CreateWriter(name string, writer tLogWriter) {
	const cFncName = cPckName + ".CreateWriter"
	if writer == nil {
		panic(fmt.Sprintf("%s: writer %s can not be nil", cFncName, name))
	}
	if _, dup := logWriters[name]; dup {
		panic(fmt.Sprintf("%s: writer %s already exists", cFncName, name))
	}
	logWriters[name] = writer
}

func (l *SLogger) StartWriter() {
	for {
		select {
		case lm := <-l.msgChan:
			for _, w := range l.writers {
				w.Write(*lm)
			}
		}
	}
}

func (l *SLogger) logw(fn string, msg string, sev tSeverity) error {
	if sev < l.severity {
		return nil
	}
	mt := &TLogMsg{fnc: fn, msg: msg, sev: sev}
	//mt := fmt.Sprintf("[%s - %s] %s", fn, sev, msg)
	// TODO: Write messages to buffer. Filter by severity
	l.msgChan <- mt
	return nil
}

func (l *SLogger) Deb(fn string, msg string) {
	// TODO: filter messages by level
	l.logw(fn, msg, SevDeb)
}

func (sev tSeverity) String() string {
	switch sev {
	case SevDeb:
		return "D"
	case SevInfo:
		return "I"
	case SevWarn:
		return "W"
	case SevErr:
		return "E"
	case SevFat:
		return "F"
	default:
		return "Unknown severity: " + string(sev)
	}
}
